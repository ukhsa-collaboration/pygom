

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scipy.interpolate._fitpack2 &#8212; PyGOM documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/scipy/interpolate/_fitpack2';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../md/intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo_pygom.jpg" class="logo__image only-light" alt="PyGOM documentation - Home"/>
    <script>document.write(`<img src="../../../_static/logo_pygom.jpg" class="logo__image only-dark" alt="PyGOM documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../md/intro.html">
                    Welcome to the documentation for PyGOM
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../md/installation.html">Installation</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../../md/building_doc.html">Building the documentation locally</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Compartmental models</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/definition.html">Introduction</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/solution.html">Mathematical description</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">PyGOM workflow</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/model_spec_2.html">Defining a system of differential equations</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../notebooks/insights.html">ODE Insights</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/extract_info.html">Extracting model information</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/unroll/unrollSimple.html">Deducing transitions from equations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../md/solving.html">Producing forecasts</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/model_params.html">Parameterisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/model_solver.html">Finding ODE solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/time_dependent_params.html">Time dependent parameters</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../md/parameter_fitting.html">Parameter fitting</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/paramfit/params_via_abc.html">Parameter Estimation: Approximate Bayesian Computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/paramfit/params_via_optimization.html">Parameter Estimation: Maximum likelihood</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/paramfit/bvpSimple.html">Solving Boundary Value Problems</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/epijson.html">Reading and using EpiJSON data</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Common biological compartmental models</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../md/common_models.html">Pre-defined examples - common epi models</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/SIS.html">SIS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/SIR.html">SIR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/SEIR.html">SEIR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/SIS_Periodic.html">SIS, periodic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/SIR_Birth_Death.html">SIR, birth and death</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/SEIR_Multiple.html">SEIR, multiple</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/SEIR_Birth_Death_Periodic_Waning_Intro.html">SEIR, birth, death, periodic, waning and introductions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/Legrand_Ebola_SEIHFR.html">Legrand Ebola SEIHFR</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/Lotka_Volterra.html">Lotka Volterra</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../notebooks/common_models/FitzHugh.html">FitzHugh</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Frequently asked questions</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../md/faq.html">Frequently asked questions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Code documentation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../rst/autodoc-model.html">model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/autodoc-loss.html">loss</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/autodoc-abc.html">approximate_bayesian_computation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/autodoc-utilR.html">utilR</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../md/bib.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/ukhsa-collaboration/pygom" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/ukhsa-collaboration/pygom/issues/new?title=Issue%20on%20page%20%2F_modules/scipy/interpolate/_fitpack2.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for scipy.interpolate._fitpack2</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">fitpack --- curve and surface fitting with splines</span>

<span class="sd">fitpack is based on a collection of Fortran routines DIERCKX</span>
<span class="sd">by P. Dierckx (see http://www.netlib.org/dierckx/) transformed</span>
<span class="sd">to double routines by Pearu Peterson.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Created by Pearu Peterson, June,August 2003</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;UnivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;InterpolatedUnivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LSQUnivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;BivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LSQBivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SmoothBivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LSQSphereBivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SmoothSphereBivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;RectBivariateSpline&#39;</span><span class="p">,</span>
    <span class="s1">&#39;RectSphereBivariateSpline&#39;</span><span class="p">]</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lock</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">ravel</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">array</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_fitpack_impl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_dfitpack</span> <span class="k">as</span> <span class="n">dfitpack</span>


<span class="n">dfitpack_int</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intvar</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">FITPACK_LOCK</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>


<span class="c1"># ############### Univariate spline ####################</span>

<span class="n">_curfit_messages</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The required storage space exceeds the available storage space, as</span>
<span class="s2">specified by the parameter nest: nest too small. If nest is already</span>
<span class="s2">large (say nest &gt; m/2), it may also indicate that s is too small.</span>
<span class="s2">The approximation returned is the weighted least-squares spline</span>
<span class="s2">according to the knots t[0],t[1],...,t[n-1]. (n=nest) the parameter fp</span>
<span class="s2">gives the corresponding weighted sum of squared residuals (fp&gt;s).</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">A theoretically impossible result was found during the iteration</span>
<span class="s2">process for finding a smoothing spline with fp = s: s too small.</span>
<span class="s2">There is an approximation returned but the corresponding weighted sum</span>
<span class="s2">of squared residuals does not satisfy the condition abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The maximal number of iterations maxit (set to 20 by the program)</span>
<span class="s2">allowed for finding a smoothing spline with fp=s has been reached: s</span>
<span class="s2">too small.</span>
<span class="s2">There is an approximation returned but the corresponding weighted sum</span>
<span class="s2">of squared residuals does not satisfy the condition abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Error on entry, no approximation returned. The following conditions</span>
<span class="s2">must hold:</span>
<span class="s2">xb&lt;=x[0]&lt;x[1]&lt;...&lt;x[m-1]&lt;=xe, w[i]&gt;0, i=0..m-1</span>
<span class="s2">if iopt=-1:</span>
<span class="s2">  xb&lt;t[k+1]&lt;t[k+2]&lt;...&lt;t[n-k-2]&lt;xe&quot;&quot;&quot;</span>
                    <span class="p">}</span>


<span class="c1"># UnivariateSpline, ext parameter can be an int or a string</span>
<span class="n">_extrap_modes</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;zeros&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                 <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;const&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>


<div class="viewcode-block" id="UnivariateSpline"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">UnivariateSpline</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1-D smoothing spline fit to a given set of data points.</span>

<span class="sd">    .. legacy:: class</span>

<span class="sd">        Specifically, we recommend using `make_splrep` instead.</span>

<span class="sd">    Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data.  `s`</span>
<span class="sd">    specifies the number of knots by specifying a smoothing condition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N,) array_like</span>
<span class="sd">        1-D array of independent input data. Must be increasing;</span>
<span class="sd">        must be strictly increasing if `s` is 0.</span>
<span class="sd">    y : (N,) array_like</span>
<span class="sd">        1-D array of dependent input data, of the same length as `x`.</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        Weights for spline fitting.  Must be positive.  If `w` is None,</span>
<span class="sd">        weights are all 1. Default is None.</span>
<span class="sd">    bbox : (2,) array_like, optional</span>
<span class="sd">        2-sequence specifying the boundary of the approximation interval. If</span>
<span class="sd">        `bbox` is None, ``bbox=[x[0], x[-1]]``. Default is None.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5.</span>
<span class="sd">        ``k = 3`` is a cubic spline. Default is 3.</span>
<span class="sd">    s : float or None, optional</span>
<span class="sd">        Positive smoothing factor used to choose the number of knots.  Number</span>
<span class="sd">        of knots will be increased until the smoothing condition is satisfied::</span>

<span class="sd">            sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) &lt;= s</span>

<span class="sd">        However, because of numerical issues, the actual condition is::</span>

<span class="sd">            abs(sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) - s) &lt; 0.001 * s</span>

<span class="sd">        If `s` is None, `s` will be set as `len(w)` for a smoothing spline</span>
<span class="sd">        that uses all data points.</span>
<span class="sd">        If 0, spline will interpolate through all data points. This is</span>
<span class="sd">        equivalent to `InterpolatedUnivariateSpline`.</span>
<span class="sd">        Default is None.</span>
<span class="sd">        The user can use the `s` to control the tradeoff between closeness</span>
<span class="sd">        and smoothness of fit. Larger `s` means more smoothing while smaller</span>
<span class="sd">        values of `s` indicate less smoothing.</span>
<span class="sd">        Recommended values of `s` depend on the weights, `w`. If the weights</span>
<span class="sd">        represent the inverse of the standard-deviation of `y`, then a good</span>
<span class="sd">        `s` value should be found in the range (m-sqrt(2*m),m+sqrt(2*m))</span>
<span class="sd">        where m is the number of datapoints in `x`, `y`, and `w`. This means</span>
<span class="sd">        ``s = len(w)`` should be a good value if ``1/w[i]`` is an</span>
<span class="sd">        estimate of the standard deviation of ``y[i]``.</span>
<span class="sd">    ext : int or str, optional</span>
<span class="sd">        Controls the extrapolation mode for elements</span>
<span class="sd">        not in the interval defined by the knot sequence.</span>

<span class="sd">        * if ext=0 or &#39;extrapolate&#39;, return the extrapolated value.</span>
<span class="sd">        * if ext=1 or &#39;zeros&#39;, return 0</span>
<span class="sd">        * if ext=2 or &#39;raise&#39;, raise a ValueError</span>
<span class="sd">        * if ext=3 or &#39;const&#39;, return the boundary value.</span>

<span class="sd">        Default is 0.</span>

<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input arrays contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination or non-sensical results) if the inputs</span>
<span class="sd">        do contain infinities or NaNs.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    RectSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh on a sphere</span>
<span class="sd">    SmoothSphereBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline in spherical coordinates</span>
<span class="sd">    LSQSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline in spherical coordinates using weighted</span>
<span class="sd">        least-squares fitting</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh</span>
<span class="sd">    InterpolatedUnivariateSpline :</span>
<span class="sd">        a interpolating univariate spline for a given set of data points.</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>
<span class="sd">    splrep :</span>
<span class="sd">        a function to find the B-spline representation of a 1-D curve</span>
<span class="sd">    splev :</span>
<span class="sd">        a function to evaluate a B-spline or its derivatives</span>
<span class="sd">    sproot :</span>
<span class="sd">        a function to find the roots of a cubic B-spline</span>
<span class="sd">    splint :</span>
<span class="sd">        a function to evaluate the definite integral of a B-spline between two</span>
<span class="sd">        given points</span>
<span class="sd">    spalde :</span>
<span class="sd">        a function to evaluate all derivatives of a B-spline</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The number of data points must be larger than the spline degree `k`.</span>

<span class="sd">    **NaN handling**: If the input arrays contain ``nan`` values, the result</span>
<span class="sd">    is not useful, since the underlying spline fitting routines cannot deal</span>
<span class="sd">    with ``nan``. A workaround is to use zero weights for not-a-number</span>
<span class="sd">    data points:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline</span>
<span class="sd">    &gt;&gt;&gt; x, y = np.array([1, 2, 3, 4]), np.array([1, np.nan, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; w = np.isnan(y)</span>
<span class="sd">    &gt;&gt;&gt; y[w] = 0.</span>
<span class="sd">    &gt;&gt;&gt; spl = UnivariateSpline(x, y, w=~w)</span>

<span class="sd">    Notice the need to replace a ``nan`` by a numerical value (precise value</span>
<span class="sd">    does not matter as long as the corresponding weight is zero.)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Based on algorithms described in [1]_, [2]_, [3]_, and [4]_:</span>

<span class="sd">    .. [1] P. Dierckx, &quot;An algorithm for smoothing, differentiation and</span>
<span class="sd">       integration of experimental data using spline functions&quot;,</span>
<span class="sd">       J.Comp.Appl.Maths 1 (1975) 165-184.</span>
<span class="sd">    .. [2] P. Dierckx, &quot;A fast algorithm for smoothing data on a rectangular</span>
<span class="sd">       grid while using spline functions&quot;, SIAM J.Numer.Anal. 19 (1982)</span>
<span class="sd">       1286-1304.</span>
<span class="sd">    .. [3] P. Dierckx, &quot;An improved algorithm for curve fitting with spline</span>
<span class="sd">       functions&quot;, report tw54, Dept. Computer Science,K.U. Leuven, 1981.</span>
<span class="sd">    .. [4] P. Dierckx, &quot;Curve and surface fitting with splines&quot;, Monographs on</span>
<span class="sd">       Numerical Analysis, Oxford University Press, 1993.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-3, 3, 50)</span>
<span class="sd">    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;ro&#39;, ms=5)</span>

<span class="sd">    Use the default value for the smoothing parameter:</span>

<span class="sd">    &gt;&gt;&gt; spl = UnivariateSpline(x, y)</span>
<span class="sd">    &gt;&gt;&gt; xs = np.linspace(-3, 3, 1000)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xs, spl(xs), &#39;g&#39;, lw=3)</span>

<span class="sd">    Manually change the amount of smoothing:</span>

<span class="sd">    &gt;&gt;&gt; spl.set_smoothing_factor(0.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xs, spl(xs), &#39;b&#39;, lw=3)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span>
                                                      <span class="n">check_finite</span><span class="p">)</span>

        <span class="c1"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">fpcurf0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">xb</span><span class="o">=</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">xe</span><span class="o">=</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># nest too small, setting to maximum bound</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_nest</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_class</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_finite</span><span class="p">:</span>
            <span class="n">w_finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="n">w_finite</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y array must not contain &quot;</span>
                                 <span class="s2">&quot;NaNs or infs.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be increasing if s &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be strictly increasing if s = 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y should have a same length&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">w</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x, y, and w should have a same length&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bbox</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bbox shape should be (2,)&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;k should be 1 &lt;= k &lt;= 5&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;s should be s &gt;= 0.0&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">_extrap_modes</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown extrapolation mode </span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">ext</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_tck</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tck</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spline object from given tck&quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tck</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span> <span class="o">=</span> <span class="n">tck</span>
        <span class="c1"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span>
                      <span class="n">c</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="n">ext</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span> <span class="o">=</span> <span class="n">t</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">c</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">k</span>
        <span class="k">if</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># the spline returned has a residual sum of squares fp</span>
            <span class="c1"># such that abs(fp-s)/s &lt;= tol with tol a relative</span>
            <span class="c1"># tolerance set to 0.001 by the program</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">ier</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># the spline returned is an interpolating spline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_class</span><span class="p">(</span><span class="n">InterpolatedUnivariateSpline</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ier</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1"># the spline returned is the weighted least-squares</span>
            <span class="c1"># polynomial of degree k. In this extreme case fp gives</span>
            <span class="c1"># the upper bound fp0 for the smoothing factor s.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_class</span><span class="p">(</span><span class="n">LSQUnivariateSpline</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># error</span>
            <span class="k">if</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_class</span><span class="p">(</span><span class="n">LSQUnivariateSpline</span><span class="p">)</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">_curfit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;ier=</span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spline_class</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">in</span> <span class="p">(</span><span class="n">UnivariateSpline</span><span class="p">,</span> <span class="n">InterpolatedUnivariateSpline</span><span class="p">,</span>
                              <span class="n">LSQUnivariateSpline</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># It&#39;s an unknown subclass -- don&#39;t change class. cf. #731</span>
            <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reset_nest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nest</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span>  <span class="c1"># this is the maximum bound for nest</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">nest</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`nest` can only be increased&quot;</span><span class="p">)</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fpint</span><span class="p">,</span> <span class="n">nrdata</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nest</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span>
                               <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

        <span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">fpint</span><span class="p">,</span> <span class="n">nrdata</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">13</span><span class="p">])</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">fpcurf1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="UnivariateSpline.set_smoothing_factor"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.set_smoothing_factor">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_smoothing_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Continue spline computation with the given smoothing</span>
<span class="sd">        factor s and with the knots found at the last call.</span>

<span class="sd">        This routine modifies the spline in place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;smoothing factor unchanged for&#39;</span>
                          <span class="s1">&#39;LSQ spline with fixed knots&#39;</span><span class="p">,</span>
                          <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">,)</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">:]</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">fpcurf1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># nest too small, setting to maximum bound</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_nest</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_class</span><span class="p">()</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate spline (or its nu-th derivative) at positions x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            A 1-D array of points at which to return the value of the smoothed</span>
<span class="sd">            spline or its derivatives. Note: `x` can be unordered but the</span>
<span class="sd">            evaluation is more efficient if `x` is (partially) ordered.</span>
<span class="sd">        nu  : int</span>
<span class="sd">            The order of derivative of the spline to compute.</span>
<span class="sd">        ext : int</span>
<span class="sd">            Controls the value returned for elements of `x` not in the</span>
<span class="sd">            interval defined by the knot sequence.</span>

<span class="sd">            * if ext=0 or &#39;extrapolate&#39;, return the extrapolated value.</span>
<span class="sd">            * if ext=1 or &#39;zeros&#39;, return 0</span>
<span class="sd">            * if ext=2 or &#39;raise&#39;, raise a ValueError</span>
<span class="sd">            * if ext=3 or &#39;const&#39;, return the boundary value.</span>

<span class="sd">            The default value is 0, passed from the initialization of</span>
<span class="sd">            UnivariateSpline.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># empty input yields empty output</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">array</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ext</span> <span class="o">=</span> <span class="n">_extrap_modes</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown extrapolation mode </span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_fitpack_impl</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="n">nu</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>

<div class="viewcode-block" id="UnivariateSpline.get_knots"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.get_knots">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return positions of interior knots of the spline.</span>

<span class="sd">        Internally, the knot vector contains ``2*k`` additional boundary knots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="n">k</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">]</span></div>

<div class="viewcode-block" id="UnivariateSpline.get_coeffs"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.get_coeffs">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return spline coefficients.&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="mi">9</span><span class="p">][:</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="UnivariateSpline.get_residual"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.get_residual">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return weighted sum of squared residuals of the spline approximation.</span>

<span class="sd">           This is equivalent to::</span>

<span class="sd">                sum((w[i] * (y[i]-spl(x[i])))**2, axis=0)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span></div>

<div class="viewcode-block" id="UnivariateSpline.integral"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.integral">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return definite integral of the spline between two given points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : float</span>
<span class="sd">            Lower limit of integration.</span>
<span class="sd">        b : float</span>
<span class="sd">            Upper limit of integration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integral : float</span>
<span class="sd">            The value of the definite integral of the spline between limits.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(0, 3, 11)</span>
<span class="sd">        &gt;&gt;&gt; y = x**2</span>
<span class="sd">        &gt;&gt;&gt; spl = UnivariateSpline(x, y)</span>
<span class="sd">        &gt;&gt;&gt; spl.integral(0, 3)</span>
<span class="sd">        9.0</span>

<span class="sd">        which agrees with :math:`\\int x^2 dx = x^3 / 3` between the limits</span>
<span class="sd">        of 0 and 3.</span>

<span class="sd">        A caveat is that this routine assumes the spline to be zero outside of</span>
<span class="sd">        the data limits:</span>

<span class="sd">        &gt;&gt;&gt; spl.integral(-1, 4)</span>
<span class="sd">        9.0</span>
<span class="sd">        &gt;&gt;&gt; spl.integral(-1, 0)</span>
<span class="sd">        0.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_fitpack_impl</span><span class="o">.</span><span class="n">splint</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnivariateSpline.derivatives"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.derivatives">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return all derivatives of the spline at the point x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            The point to evaluate the derivatives at.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        der : ndarray, shape(k+1,)</span>
<span class="sd">            Derivatives of the orders 0 to k.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(0, 3, 11)</span>
<span class="sd">        &gt;&gt;&gt; y = x**2</span>
<span class="sd">        &gt;&gt;&gt; spl = UnivariateSpline(x, y)</span>
<span class="sd">        &gt;&gt;&gt; spl.derivatives(1.5)</span>
<span class="sd">        array([2.25, 3.0, 2.0, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_fitpack_impl</span><span class="o">.</span><span class="n">spalde</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnivariateSpline.roots"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.roots">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the zeros of the spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Restriction: only cubic splines are supported by FITPACK. For non-cubic</span>
<span class="sd">        splines, use `PPoly.root` (see below for an example).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        For some data, this method may miss a root. This happens when one of</span>
<span class="sd">        the spline knots (which FITPACK places automatically) happens to</span>
<span class="sd">        coincide with the true root. A workaround is to convert to `PPoly`,</span>
<span class="sd">        which uses a different root-finding algorithm.</span>

<span class="sd">        For example,</span>

<span class="sd">        &gt;&gt;&gt; x = [1.96, 1.97, 1.98, 1.99, 2.00, 2.01, 2.02, 2.03, 2.04, 2.05]</span>
<span class="sd">        &gt;&gt;&gt; y = [-6.365470e-03, -4.790580e-03, -3.204320e-03, -1.607270e-03,</span>
<span class="sd">        ...      4.440892e-16,  1.616930e-03,  3.243000e-03,  4.877670e-03,</span>
<span class="sd">        ...      6.520430e-03,  8.170770e-03]</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; spl = UnivariateSpline(x, y, s=0)</span>
<span class="sd">        &gt;&gt;&gt; spl.roots()</span>
<span class="sd">        array([], dtype=float64)</span>

<span class="sd">        Converting to a PPoly object does find the roots at `x=2`:</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import splrep, PPoly</span>
<span class="sd">        &gt;&gt;&gt; tck = splrep(x, y, s=0)</span>
<span class="sd">        &gt;&gt;&gt; ppoly = PPoly.from_spline(tck)</span>
<span class="sd">        &gt;&gt;&gt; ppoly.roots(extrapolate=False)</span>
<span class="sd">        array([2.])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sproot</span>
<span class="sd">        PPoly.roots</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mest</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mi">7</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_fitpack_impl</span><span class="o">.</span><span class="n">sproot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span><span class="p">,</span> <span class="n">mest</span><span class="o">=</span><span class="n">mest</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;finding roots unsupported for &#39;</span>
                                  <span class="s1">&#39;non-cubic splines&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnivariateSpline.derivative"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.derivative">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new spline representing the derivative of this spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Default: 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : UnivariateSpline</span>
<span class="sd">            Spline of order k2=k-n representing the derivative of this</span>
<span class="sd">            spline.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        splder, antiderivative</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. versionadded:: 0.13.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This can be used for finding maxima of a curve:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(0, 10, 70)</span>
<span class="sd">        &gt;&gt;&gt; y = np.sin(x)</span>
<span class="sd">        &gt;&gt;&gt; spl = UnivariateSpline(x, y, k=4, s=0)</span>

<span class="sd">        Now, differentiate the spline and find the zeros of the</span>
<span class="sd">        derivative. (NB: `sproot` only works for order 3 splines, so we</span>
<span class="sd">        fit an order 4 spline):</span>

<span class="sd">        &gt;&gt;&gt; spl.derivative().roots() / np.pi</span>
<span class="sd">        array([ 0.50000001,  1.5       ,  2.49999998])</span>

<span class="sd">        This agrees well with roots :math:`\\pi/2 + n\\pi` of</span>
<span class="sd">        :math:`\\cos(x) = \\sin&#39;(x)`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="n">_fitpack_impl</span><span class="o">.</span><span class="n">splder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="c1"># if self.ext is &#39;const&#39;, derivative.ext will be &#39;zeros&#39;</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span>
        <span class="k">return</span> <span class="n">UnivariateSpline</span><span class="o">.</span><span class="n">_from_tck</span><span class="p">(</span><span class="n">tck</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span></div>

<div class="viewcode-block" id="UnivariateSpline.antiderivative"><a class="viewcode-back" href="../../../rst/autodoc-loss.html#pygom.loss.UnivariateSpline.antiderivative">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new spline representing the antiderivative of this spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int, optional</span>
<span class="sd">            Order of antiderivative to evaluate. Default: 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline : UnivariateSpline</span>
<span class="sd">            Spline of order k2=k+n representing the antiderivative of this</span>
<span class="sd">            spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. versionadded:: 0.13.0</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        splantider, derivative</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(0, np.pi/2, 70)</span>
<span class="sd">        &gt;&gt;&gt; y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2)</span>
<span class="sd">        &gt;&gt;&gt; spl = UnivariateSpline(x, y, s=0)</span>

<span class="sd">        The derivative is the inverse operation of the antiderivative,</span>
<span class="sd">        although some floating point error accumulates:</span>

<span class="sd">        &gt;&gt;&gt; spl(1.7), spl.antiderivative().derivative()(1.7)</span>
<span class="sd">        (array(2.1565429877197317), array(2.1565429877201865))</span>

<span class="sd">        Antiderivative can be used to evaluate definite integrals:</span>

<span class="sd">        &gt;&gt;&gt; ispl = spl.antiderivative()</span>
<span class="sd">        &gt;&gt;&gt; ispl(np.pi/2) - ispl(0)</span>
<span class="sd">        2.2572053588768486</span>

<span class="sd">        This is indeed an approximation to the complete elliptic integral</span>
<span class="sd">        :math:`K(m) = \\int_0^{\\pi/2} [1 - m\\sin^2 x]^{-1/2} dx`:</span>

<span class="sd">        &gt;&gt;&gt; from scipy.special import ellipk</span>
<span class="sd">        &gt;&gt;&gt; ellipk(0.8)</span>
<span class="sd">        2.2572053268208538</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">tck</span> <span class="o">=</span> <span class="n">_fitpack_impl</span><span class="o">.</span><span class="n">splantider</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eval_args</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">UnivariateSpline</span><span class="o">.</span><span class="n">_from_tck</span><span class="p">(</span><span class="n">tck</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span><span class="p">)</span></div></div>


<span class="k">class</span><span class="w"> </span><span class="nc">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">UnivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1-D interpolating spline for a given set of data points.</span>

<span class="sd">    .. legacy:: class</span>

<span class="sd">        Specifically, we recommend using `make_interp_spline` instead.</span>

<span class="sd">    Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data.</span>
<span class="sd">    Spline function passes through all provided points. Equivalent to</span>
<span class="sd">    `UnivariateSpline` with  `s` = 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N,) array_like</span>
<span class="sd">        Input dimension of data points -- must be strictly increasing</span>
<span class="sd">    y : (N,) array_like</span>
<span class="sd">        input dimension of data points</span>
<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        Weights for spline fitting.  Must be positive.  If None (default),</span>
<span class="sd">        weights are all 1.</span>
<span class="sd">    bbox : (2,) array_like, optional</span>
<span class="sd">        2-sequence specifying the boundary of the approximation interval. If</span>
<span class="sd">        None (default), ``bbox=[x[0], x[-1]]``.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Degree of the smoothing spline.  Must be ``1 &lt;= k &lt;= 5``. Default is</span>
<span class="sd">        ``k = 3``, a cubic spline.</span>
<span class="sd">    ext : int or str, optional</span>
<span class="sd">        Controls the extrapolation mode for elements</span>
<span class="sd">        not in the interval defined by the knot sequence.</span>

<span class="sd">        * if ext=0 or &#39;extrapolate&#39;, return the extrapolated value.</span>
<span class="sd">        * if ext=1 or &#39;zeros&#39;, return 0</span>
<span class="sd">        * if ext=2 or &#39;raise&#39;, raise a ValueError</span>
<span class="sd">        * if ext=3 of &#39;const&#39;, return the boundary value.</span>

<span class="sd">        The default value is 0.</span>

<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input arrays contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination or non-sensical results) if the inputs</span>
<span class="sd">        do contain infinities or NaNs.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    LSQUnivariateSpline :</span>
<span class="sd">        a spline for which knots are user-selected</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    splrep :</span>
<span class="sd">        a function to find the B-spline representation of a 1-D curve</span>
<span class="sd">    splev :</span>
<span class="sd">        a function to evaluate a B-spline or its derivatives</span>
<span class="sd">    sproot :</span>
<span class="sd">        a function to find the roots of a cubic B-spline</span>
<span class="sd">    splint :</span>
<span class="sd">        a function to evaluate the definite integral of a B-spline between two</span>
<span class="sd">        given points</span>
<span class="sd">    spalde :</span>
<span class="sd">        a function to evaluate all derivatives of a B-spline</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The number of data points must be larger than the spline degree `k`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import InterpolatedUnivariateSpline</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-3, 3, 50)</span>
<span class="sd">    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)</span>
<span class="sd">    &gt;&gt;&gt; spl = InterpolatedUnivariateSpline(x, y)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;ro&#39;, ms=5)</span>
<span class="sd">    &gt;&gt;&gt; xs = np.linspace(-3, 3, 1000)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xs, spl(xs), &#39;g&#39;, lw=3, alpha=0.7)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Notice that the ``spl(x)`` interpolates `y`:</span>

<span class="sd">    &gt;&gt;&gt; spl.get_residual()</span>
<span class="sd">    0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                            <span class="n">ext</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be strictly increasing&#39;</span><span class="p">)</span>

        <span class="c1"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">fpcurf0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">xb</span><span class="o">=</span><span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">xe</span><span class="o">=</span><span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_class</span><span class="p">()</span>


<span class="n">_fpchec_error_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;The input parameters have been rejected by fpchec. </span><span class="se">\</span>
<span class="s2">This means that at least one of the following conditions is violated:</span>

<span class="s2">1) k+1 &lt;= n-k-1 &lt;= m</span>
<span class="s2">2) t(1) &lt;= t(2) &lt;= ... &lt;= t(k+1)</span>
<span class="s2">   t(n-k) &lt;= t(n-k+1) &lt;= ... &lt;= t(n)</span>
<span class="s2">3) t(k+1) &lt; t(k+2) &lt; ... &lt; t(n-k)</span>
<span class="s2">4) t(k+1) &lt;= x(i) &lt;= t(n-k)</span>
<span class="s2">5) The conditions specified by Schoenberg and Whitney must hold</span>
<span class="s2">   for at least one subset of data points, i.e., there must be a</span>
<span class="s2">   subset of data points y(j) such that</span>
<span class="s2">       t(j) &lt; y(j) &lt; t(j+k+1), j=1,2,...,n-k-1</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LSQUnivariateSpline</span><span class="p">(</span><span class="n">UnivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1-D spline with explicit internal knots.</span>

<span class="sd">    .. legacy:: class</span>

<span class="sd">        Specifically, we recommend using `make_lsq_spline` instead.</span>


<span class="sd">    Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data.  `t`</span>
<span class="sd">    specifies the internal knots of the spline</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (N,) array_like</span>
<span class="sd">        Input dimension of data points -- must be increasing</span>
<span class="sd">    y : (N,) array_like</span>
<span class="sd">        Input dimension of data points</span>
<span class="sd">    t : (M,) array_like</span>
<span class="sd">        interior knots of the spline.  Must be in ascending order and::</span>

<span class="sd">            bbox[0] &lt; t[0] &lt; ... &lt; t[-1] &lt; bbox[-1]</span>

<span class="sd">    w : (N,) array_like, optional</span>
<span class="sd">        weights for spline fitting. Must be positive. If None (default),</span>
<span class="sd">        weights are all 1.</span>
<span class="sd">    bbox : (2,) array_like, optional</span>
<span class="sd">        2-sequence specifying the boundary of the approximation interval. If</span>
<span class="sd">        None (default), ``bbox = [x[0], x[-1]]``.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5.</span>
<span class="sd">        Default is `k` = 3, a cubic spline.</span>
<span class="sd">    ext : int or str, optional</span>
<span class="sd">        Controls the extrapolation mode for elements</span>
<span class="sd">        not in the interval defined by the knot sequence.</span>

<span class="sd">        * if ext=0 or &#39;extrapolate&#39;, return the extrapolated value.</span>
<span class="sd">        * if ext=1 or &#39;zeros&#39;, return 0</span>
<span class="sd">        * if ext=2 or &#39;raise&#39;, raise a ValueError</span>
<span class="sd">        * if ext=3 of &#39;const&#39;, return the boundary value.</span>

<span class="sd">        The default value is 0.</span>

<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input arrays contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination or non-sensical results) if the inputs</span>
<span class="sd">        do contain infinities or NaNs.</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the interior knots do not satisfy the Schoenberg-Whitney conditions</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    InterpolatedUnivariateSpline :</span>
<span class="sd">        a interpolating univariate spline for a given set of data points.</span>
<span class="sd">    splrep :</span>
<span class="sd">        a function to find the B-spline representation of a 1-D curve</span>
<span class="sd">    splev :</span>
<span class="sd">        a function to evaluate a B-spline or its derivatives</span>
<span class="sd">    sproot :</span>
<span class="sd">        a function to find the roots of a cubic B-spline</span>
<span class="sd">    splint :</span>
<span class="sd">        a function to evaluate the definite integral of a B-spline between two</span>
<span class="sd">        given points</span>
<span class="sd">    spalde :</span>
<span class="sd">        a function to evaluate all derivatives of a B-spline</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The number of data points must be larger than the spline degree `k`.</span>

<span class="sd">    Knots `t` must satisfy the Schoenberg-Whitney conditions,</span>
<span class="sd">    i.e., there must be a subset of data points ``x[j]`` such that</span>
<span class="sd">    ``t[j] &lt; x[j] &lt; t[j+k+1]``, for ``j=0, 1,...,n-k-2``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import LSQUnivariateSpline, UnivariateSpline</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-3, 3, 50)</span>
<span class="sd">    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50)</span>

<span class="sd">    Fit a smoothing spline with a pre-defined internal knots:</span>

<span class="sd">    &gt;&gt;&gt; t = [-1, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; spl = LSQUnivariateSpline(x, y, t)</span>

<span class="sd">    &gt;&gt;&gt; xs = np.linspace(-3, 3, 1000)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;ro&#39;, ms=5)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xs, spl(xs), &#39;g-&#39;, lw=3)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Check the knot vector:</span>

<span class="sd">    &gt;&gt;&gt; spl.get_knots()</span>
<span class="sd">    array([-3., -1., 0., 1., 3.])</span>

<span class="sd">    Constructing lsq spline using the knots from another spline:</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; s = UnivariateSpline(x, x, s=0)</span>
<span class="sd">    &gt;&gt;&gt; s.get_knots()</span>
<span class="sd">    array([ 0.,  2.,  3.,  4.,  5.,  6.,  7.,  9.])</span>
<span class="sd">    &gt;&gt;&gt; knt = s.get_knots()</span>
<span class="sd">    &gt;&gt;&gt; s1 = LSQUnivariateSpline(x, x, knt[1:-1])    # Chop 1st and last knot</span>
<span class="sd">    &gt;&gt;&gt; s1.get_knots()</span>
<span class="sd">    array([ 0.,  2.,  3.,  4.,  5.,  6.,  7.,  9.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                                      <span class="n">ext</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be increasing&#39;</span><span class="p">)</span>

        <span class="c1"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="n">xb</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xe</span> <span class="o">=</span> <span class="n">bbox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xb</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xe</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xe</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(([</span><span class="n">xb</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="n">xe</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Interior knots t must satisfy &#39;</span>
                             <span class="s1">&#39;Schoenberg-Whitney conditions&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">fpchec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_fpchec_error_string</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">fpcurfm1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">xb</span><span class="o">=</span><span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="o">=</span><span class="n">xe</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_class</span><span class="p">()</span>


<span class="c1"># ############### Bivariate spline ####################</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_BivariateSplineBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Base class for Bivariate spline s(x,y) interpolation on the rectangle</span>
<span class="sd">    [xb,xe] x [yb, ye] calculated from a given set of data points</span>
<span class="sd">    (x,y,z).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    SphereBivariateSpline :</span>
<span class="sd">        a bivariate spline on a spherical grid</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_from_tck</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tck</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a spline object from given tck and degree&quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tck</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;tck should be a 5 element tuple of tx,&quot;</span>
                             <span class="s2">&quot; ty, c, kx, ky&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">tck</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">tck</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return weighted sum of squared residuals of the spline</span>
<span class="sd">        approximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_knots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a tuple (tx,ty) where tx,ty contain knots positions</span>
<span class="sd">        of the spline with respect to x-, y-variable, respectively.</span>
<span class="sd">        The position of interior and additional knots are given as</span>
<span class="sd">        t[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return spline coefficients.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the spline or its derivatives at given positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array_like</span>
<span class="sd">            Input coordinates.</span>

<span class="sd">            If `grid` is False, evaluate the spline at points ``(x[i],</span>
<span class="sd">            y[i]), i=0, ..., len(x)-1``.  Standard Numpy broadcasting</span>
<span class="sd">            is obeyed.</span>

<span class="sd">            If `grid` is True: evaluate spline at the grid points</span>
<span class="sd">            defined by the coordinate arrays x, y. The arrays must be</span>
<span class="sd">            sorted to increasing order.</span>

<span class="sd">            The ordering of axes is consistent with</span>
<span class="sd">            ``np.meshgrid(..., indexing=&quot;ij&quot;)`` and inconsistent with the</span>
<span class="sd">            default ordering ``np.meshgrid(..., indexing=&quot;xy&quot;)``.</span>
<span class="sd">        dx : int</span>
<span class="sd">            Order of x-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>
<span class="sd">        dy : int</span>
<span class="sd">            Order of y-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>
<span class="sd">        grid : bool</span>
<span class="sd">            Whether to evaluate the results on a grid spanned by the</span>
<span class="sd">            input arrays, or at points specified by the input arrays.</span>

<span class="sd">            .. versionadded:: 0.14.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Suppose that we want to bilinearly interpolate an exponentially decaying</span>
<span class="sd">        function in 2 dimensions.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import RectBivariateSpline</span>

<span class="sd">        We sample the function on a coarse grid. Note that the default indexing=&quot;xy&quot;</span>
<span class="sd">        of meshgrid would result in an unexpected (transposed) result after</span>
<span class="sd">        interpolation.</span>

<span class="sd">        &gt;&gt;&gt; xarr = np.linspace(-3, 3, 100)</span>
<span class="sd">        &gt;&gt;&gt; yarr = np.linspace(-3, 3, 100)</span>
<span class="sd">        &gt;&gt;&gt; xgrid, ygrid = np.meshgrid(xarr, yarr, indexing=&quot;ij&quot;)</span>

<span class="sd">        The function to interpolate decays faster along one axis than the other.</span>

<span class="sd">        &gt;&gt;&gt; zdata = np.exp(-np.sqrt((xgrid / 2) ** 2 + ygrid**2))</span>

<span class="sd">        Next we sample on a finer grid using interpolation (kx=ky=1 for bilinear).</span>

<span class="sd">        &gt;&gt;&gt; rbs = RectBivariateSpline(xarr, yarr, zdata, kx=1, ky=1)</span>
<span class="sd">        &gt;&gt;&gt; xarr_fine = np.linspace(-3, 3, 200)</span>
<span class="sd">        &gt;&gt;&gt; yarr_fine = np.linspace(-3, 3, 200)</span>
<span class="sd">        &gt;&gt;&gt; xgrid_fine, ygrid_fine = np.meshgrid(xarr_fine, yarr_fine, indexing=&quot;ij&quot;)</span>
<span class="sd">        &gt;&gt;&gt; zdata_interp = rbs(xgrid_fine, ygrid_fine, grid=False)</span>

<span class="sd">        And check that the result agrees with the input by plotting both.</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 2, 1, aspect=&quot;equal&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax2 = fig.add_subplot(1, 2, 2, aspect=&quot;equal&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax1.imshow(zdata)</span>
<span class="sd">        &gt;&gt;&gt; ax2.imshow(zdata_interp)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be strictly increasing when `grid` is True&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y must be strictly increasing when `grid` is True&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dx</span> <span class="ow">or</span> <span class="n">dy</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">parder</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error code returned by parder: </span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">bispev</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error code returned by bispev: </span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># standard Numpy broadcasting</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dx</span> <span class="ow">or</span> <span class="n">dy</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">pardeu</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error code returned by pardeu: </span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
                    <span class="n">z</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">bispeu</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error code returned by bispeu: </span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">partial_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a new spline representing a partial derivative of this</span>
<span class="sd">        spline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dx, dy : int</span>
<span class="sd">            Orders of the derivative in x and y respectively. They must be</span>
<span class="sd">            non-negative integers and less than the respective degree of the</span>
<span class="sd">            original spline (self) in that direction (``kx``, ``ky``).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        spline :</span>
<span class="sd">            A new spline of degrees (``kx - dx``, ``ky - dy``) representing the</span>
<span class="sd">            derivative of this spline.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;order of derivative must be positive or&quot;</span>
                                 <span class="s2">&quot; zero&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dx</span> <span class="o">&lt;</span> <span class="n">kx</span> <span class="ow">and</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="n">ky</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;order of derivative must be less than&quot;</span>
                                 <span class="s2">&quot; degree of spline&quot;</span><span class="p">)</span>
            <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
                <span class="n">newc</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">pardtc</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ier</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This should not happen under normal conditions.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected error code returned by&quot;</span>
                                 <span class="s2">&quot; pardtc: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ier</span><span class="p">)</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span>
            <span class="n">newtx</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[</span><span class="n">dx</span><span class="p">:</span><span class="n">nx</span> <span class="o">-</span> <span class="n">dx</span><span class="p">]</span>
            <span class="n">newty</span> <span class="o">=</span> <span class="n">ty</span><span class="p">[</span><span class="n">dy</span><span class="p">:</span><span class="n">ny</span> <span class="o">-</span> <span class="n">dy</span><span class="p">]</span>
            <span class="n">newkx</span><span class="p">,</span> <span class="n">newky</span> <span class="o">=</span> <span class="n">kx</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ky</span> <span class="o">-</span> <span class="n">dy</span>
            <span class="n">newclen</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">-</span> <span class="n">dx</span> <span class="o">-</span> <span class="n">kx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="n">dy</span> <span class="o">-</span> <span class="n">ky</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">_DerivedBivariateSpline</span><span class="o">.</span><span class="n">_from_tck</span><span class="p">((</span><span class="n">newtx</span><span class="p">,</span> <span class="n">newty</span><span class="p">,</span>
                                                      <span class="n">newc</span><span class="p">[:</span><span class="n">newclen</span><span class="p">],</span>
                                                      <span class="n">newkx</span><span class="p">,</span> <span class="n">newky</span><span class="p">))</span>


<span class="n">_surfit_messages</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The required storage space exceeds the available storage space: nxest</span>
<span class="s2">or nyest too small, or s too small.</span>
<span class="s2">The weighted least-squares spline corresponds to the current set of</span>
<span class="s2">knots.&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">A theoretically impossible result was found during the iteration</span>
<span class="s2">process for finding a smoothing spline with fp = s: s too small or</span>
<span class="s2">badly chosen eps.</span>
<span class="s2">Weighted sum of squared residuals does not satisfy abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">the maximal number of iterations maxit (set to 20 by the program)</span>
<span class="s2">allowed for finding a smoothing spline with fp=s has been reached:</span>
<span class="s2">s too small.</span>
<span class="s2">Weighted sum of squared residuals does not satisfy abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">No more knots can be added because the number of b-spline coefficients</span>
<span class="s2">(nx-kx-1)*(ny-ky-1) already exceeds the number of data points m:</span>
<span class="s2">either s or m too small.</span>
<span class="s2">The weighted least-squares spline corresponds to the current set of</span>
<span class="s2">knots.&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">No more knots can be added because the additional knot would (quasi)</span>
<span class="s2">coincide with an old one: s too small or too large a weight to an</span>
<span class="s2">inaccurate data point.</span>
<span class="s2">The weighted least-squares spline corresponds to the current set of</span>
<span class="s2">knots.&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Error on entry, no approximation returned. The following conditions</span>
<span class="s2">must hold:</span>
<span class="s2">xb&lt;=x[i]&lt;=xe, yb&lt;=y[i]&lt;=ye, w[i]&gt;0, i=0..m-1</span>
<span class="s2">If iopt==-1, then</span>
<span class="s2">  xb&lt;tx[kx+1]&lt;tx[kx+2]&lt;...&lt;tx[nx-kx-2]&lt;xe</span>
<span class="s2">  yb&lt;ty[ky+1]&lt;ty[ky+2]&lt;...&lt;ty[ny-ky-2]&lt;ye&quot;&quot;&quot;</span><span class="p">,</span>
                    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The coefficients of the spline returned have been computed as the</span>
<span class="s2">minimal norm least-squares solution of a (numerically) rank deficient</span>
<span class="s2">system (deficiency=</span><span class="si">%i</span><span class="s2">). If deficiency is large, the results may be</span>
<span class="s2">inaccurate. Deficiency may strongly depend on the value of eps.&quot;&quot;&quot;</span>
                    <span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BivariateSpline</span><span class="p">(</span><span class="n">_BivariateSplineBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for bivariate splines.</span>

<span class="sd">    This describes a spline ``s(x, y)`` of degrees ``kx`` and ``ky`` on</span>
<span class="sd">    the rectangle ``[xb, xe] * [yb, ye]`` calculated from a given set</span>
<span class="sd">    of data points ``(x, y, z)``.</span>

<span class="sd">    This class is meant to be subclassed, not instantiated directly.</span>
<span class="sd">    To construct these splines, call either `SmoothBivariateSpline` or</span>
<span class="sd">    `LSQBivariateSpline` or `RectBivariateSpline`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    RectSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh on a sphere</span>
<span class="sd">    SmoothSphereBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline in spherical coordinates</span>
<span class="sd">    LSQSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline in spherical coordinates using weighted</span>
<span class="sd">        least-squares fitting</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh.</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the spline at points</span>

<span class="sd">        Returns the interpolated value at ``(xi[i], yi[i]),</span>
<span class="sd">        i=0,...,len(xi)-1``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi, yi : array_like</span>
<span class="sd">            Input coordinates. Standard Numpy broadcasting is obeyed.</span>
<span class="sd">            The ordering of axes is consistent with</span>
<span class="sd">            ``np.meshgrid(..., indexing=&quot;ij&quot;)`` and inconsistent with the</span>
<span class="sd">            default ordering ``np.meshgrid(..., indexing=&quot;xy&quot;)``.</span>
<span class="sd">        dx : int, optional</span>
<span class="sd">            Order of x-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>
<span class="sd">        dy : int, optional</span>
<span class="sd">            Order of y-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Suppose that we want to bilinearly interpolate an exponentially decaying</span>
<span class="sd">        function in 2 dimensions.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import RectBivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; def f(x, y):</span>
<span class="sd">        ...     return np.exp(-np.sqrt((x / 2) ** 2 + y**2))</span>

<span class="sd">        We sample the function on a coarse grid and set up the interpolator. Note that</span>
<span class="sd">        the default ``indexing=&quot;xy&quot;`` of meshgrid would result in an unexpected</span>
<span class="sd">        (transposed) result after interpolation.</span>

<span class="sd">        &gt;&gt;&gt; xarr = np.linspace(-3, 3, 21)</span>
<span class="sd">        &gt;&gt;&gt; yarr = np.linspace(-3, 3, 21)</span>
<span class="sd">        &gt;&gt;&gt; xgrid, ygrid = np.meshgrid(xarr, yarr, indexing=&quot;ij&quot;)</span>
<span class="sd">        &gt;&gt;&gt; zdata = f(xgrid, ygrid)</span>
<span class="sd">        &gt;&gt;&gt; rbs = RectBivariateSpline(xarr, yarr, zdata, kx=1, ky=1)</span>

<span class="sd">        Next we sample the function along a diagonal slice through the coordinate space</span>
<span class="sd">        on a finer grid using interpolation.</span>

<span class="sd">        &gt;&gt;&gt; xinterp = np.linspace(-3, 3, 201)</span>
<span class="sd">        &gt;&gt;&gt; yinterp = np.linspace(3, -3, 201)</span>
<span class="sd">        &gt;&gt;&gt; zinterp = rbs.ev(xinterp, yinterp)</span>

<span class="sd">        And check that the interpolation passes through the function evaluations as a</span>
<span class="sd">        function of the distance from the origin along the slice.</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 1, 1)</span>
<span class="sd">        &gt;&gt;&gt; ax1.plot(np.sqrt(xarr**2 + yarr**2), np.diag(zdata), &quot;or&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax1.plot(np.sqrt(xinterp**2 + yinterp**2), zinterp, &quot;-b&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">dy</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the integral of the spline over area [xa,xb] x [ya,yb].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa, xb : float</span>
<span class="sd">            The end-points of the x integration interval.</span>
<span class="sd">        ya, yb : float</span>
<span class="sd">            The end-points of the y integration interval.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integ : float</span>
<span class="sd">            The value of the resulting integral.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">dblint</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x, y, and z should have a same length&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">w</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x, y, z, and w should have a same length&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;w should be positive&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;eps should be between (0, 1)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">kx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ky</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The length of x, y and z should be at least&#39;</span>
                             <span class="s1">&#39; (kx+1) * (ky+1)&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_DerivedBivariateSpline</span><span class="p">(</span><span class="n">_BivariateSplineBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bivariate spline constructed from the coefficients and knots of another</span>
<span class="sd">    spline.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The class is not meant to be instantiated directly from the data to be</span>
<span class="sd">    interpolated or smoothed. As a result, its ``fp`` attribute and</span>
<span class="sd">    ``get_residual`` method are inherited but overridden; ``AttributeError`` is</span>
<span class="sd">    raised when they are accessed.</span>

<span class="sd">    The other inherited attributes can be used as usual.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_invalid_why</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;is unavailable, because _DerivedBivariateSpline&quot;</span>
                    <span class="s2">&quot; instance is not constructed from data that are to be&quot;</span>
                    <span class="s2">&quot; interpolated or smoothed, but derived from the&quot;</span>
                    <span class="s2">&quot; underlying knots and coefficients of another spline&quot;</span>
                    <span class="s2">&quot; object&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;attribute </span><span class="se">\&quot;</span><span class="s2">fp</span><span class="se">\&quot;</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_invalid_why</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;method </span><span class="se">\&quot;</span><span class="s2">get_residual</span><span class="se">\&quot;</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_invalid_why</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SmoothBivariateSpline</span><span class="p">(</span><span class="n">BivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth bivariate spline approximation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : array_like</span>
<span class="sd">        1-D sequences of data points (order is not important).</span>
<span class="sd">    w : array_like, optional</span>
<span class="sd">        Positive 1-D sequence of weights, of same length as `x`, `y` and `z`.</span>
<span class="sd">    bbox : array_like, optional</span>
<span class="sd">        Sequence of length 4 specifying the boundary of the rectangular</span>
<span class="sd">        approximation domain.  By default,</span>
<span class="sd">        ``bbox=[min(x), max(x), min(y), max(y)]``.</span>
<span class="sd">    kx, ky : ints, optional</span>
<span class="sd">        Degrees of the bivariate spline. Default is 3.</span>
<span class="sd">    s : float, optional</span>
<span class="sd">        Positive smoothing factor defined for estimation condition:</span>
<span class="sd">        ``sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) &lt;= s``</span>
<span class="sd">        Default ``s=len(w)`` which should be a good value if ``1/w[i]`` is an</span>
<span class="sd">        estimate of the standard deviation of ``z[i]``.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        A threshold for determining the effective rank of an over-determined</span>
<span class="sd">        linear system of equations. `eps` should have a value within the open</span>
<span class="sd">        interval ``(0, 1)``, the default is 1e-16.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    RectSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh on a sphere</span>
<span class="sd">    SmoothSphereBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline in spherical coordinates</span>
<span class="sd">    LSQSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline in spherical coordinates using weighted</span>
<span class="sd">        least-squares fitting</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The length of `x`, `y` and `z` should be at least ``(kx+1) * (ky+1)``.</span>

<span class="sd">    If the input data is such that input dimensions have incommensurate</span>
<span class="sd">    units and differ by many orders of magnitude, the interpolant may have</span>
<span class="sd">    numerical artifacts. Consider rescaling the data before interpolating.</span>

<span class="sd">    This routine constructs spline knot vectors automatically via the FITPACK</span>
<span class="sd">    algorithm. The spline knots may be placed away from the data points. For</span>
<span class="sd">    some data sets, this routine may fail to construct an interpolating spline,</span>
<span class="sd">    even if one is requested via ``s=0`` parameter. In such situations, it is</span>
<span class="sd">    recommended to use `bisplrep` / `bisplev` directly instead of this routine</span>
<span class="sd">    and, if needed, increase the values of ``nxest`` and ``nyest`` parameters</span>
<span class="sd">    of `bisplrep`.</span>

<span class="sd">    For linear interpolation, prefer `LinearNDInterpolator`.</span>
<span class="sd">    See ``https://gist.github.com/ev-br/8544371b40f414b7eaf3fe6217209bff``</span>
<span class="sd">    for discussion.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">kx</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">eps</span><span class="o">=</span><span class="mf">1e-16</span><span class="p">):</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bbox shape should be (4,)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;s should be s &gt;= 0.0&quot;</span><span class="p">)</span>

        <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">ye</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">wrk1</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">surfit_smth</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">lwrk2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ier</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>          <span class="c1"># lwrk2 was to small, re-run</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">wrk1</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">surfit_smth</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                    <span class="n">lwrk2</span><span class="o">=</span><span class="n">ier</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ier</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]:</span>  <span class="c1"># normal return</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">_surfit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;ier=</span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="n">nx</span><span class="p">],</span> <span class="n">ty</span><span class="p">[:</span><span class="n">ny</span><span class="p">],</span> <span class="n">c</span><span class="p">[:(</span><span class="n">nx</span><span class="o">-</span><span class="n">kx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="n">ky</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LSQBivariateSpline</span><span class="p">(</span><span class="n">BivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Weighted least-squares bivariate spline approximation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : array_like</span>
<span class="sd">        1-D sequences of data points (order is not important).</span>
<span class="sd">    tx, ty : array_like</span>
<span class="sd">        Strictly ordered 1-D sequences of knots coordinates.</span>
<span class="sd">    w : array_like, optional</span>
<span class="sd">        Positive 1-D array of weights, of the same length as `x`, `y` and `z`.</span>
<span class="sd">    bbox : (4,) array_like, optional</span>
<span class="sd">        Sequence of length 4 specifying the boundary of the rectangular</span>
<span class="sd">        approximation domain.  By default,</span>
<span class="sd">        ``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``.</span>
<span class="sd">    kx, ky : ints, optional</span>
<span class="sd">        Degrees of the bivariate spline. Default is 3.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        A threshold for determining the effective rank of an over-determined</span>
<span class="sd">        linear system of equations. `eps` should have a value within the open</span>
<span class="sd">        interval ``(0, 1)``, the default is 1e-16.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    RectSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh on a sphere</span>
<span class="sd">    SmoothSphereBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline in spherical coordinates</span>
<span class="sd">    LSQSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline in spherical coordinates using weighted</span>
<span class="sd">        least-squares fitting</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh.</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The length of `x`, `y` and `z` should be at least ``(kx+1) * (ky+1)``.</span>

<span class="sd">    If the input data is such that input dimensions have incommensurate</span>
<span class="sd">    units and differ by many orders of magnitude, the interpolant may have</span>
<span class="sd">    numerical artifacts. Consider rescaling the data before interpolating.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">kx</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bbox shape should be (4,)&#39;</span><span class="p">)</span>

        <span class="n">nx</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">kx</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">ky</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">ty</span><span class="p">)</span>
        <span class="c1"># The Fortran subroutine &quot;surfit&quot; (called as dfitpack.surfit_lsq)</span>
        <span class="c1"># requires that the knot arrays passed as input should be &quot;real</span>
        <span class="c1"># array(s) of dimension nmax&quot; where &quot;nmax&quot; refers to the greater of nx</span>
        <span class="c1"># and ny. We pad the tx1/ty1 arrays here so that this is satisfied, and</span>
        <span class="c1"># slice them to the desired sizes upon return.</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="n">tx1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">ty1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nmax</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">tx1</span><span class="p">[</span><span class="n">kx</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">nx</span><span class="o">-</span><span class="n">kx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tx</span>
        <span class="n">ty1</span><span class="p">[</span><span class="n">ky</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ny</span><span class="o">-</span><span class="n">ky</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ty</span>

        <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">ye</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">tx1</span><span class="p">,</span> <span class="n">ty1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">surfit_lsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">tx1</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ty1</span><span class="p">,</span>
                                                    <span class="n">w</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span>
                                                    <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">lwrk2</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ier</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">tx1</span><span class="p">,</span> <span class="n">ty1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">surfit_lsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span>
                                                        <span class="n">nx</span><span class="p">,</span> <span class="n">tx1</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ty1</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span>
                                                        <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">ye</span><span class="p">,</span>
                                                        <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">lwrk2</span><span class="o">=</span><span class="n">ier</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ier</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]:</span>  <span class="c1"># normal return</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ier</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">deficiency</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span><span class="o">-</span><span class="n">kx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="n">ky</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">ier</span>
                <span class="n">message</span> <span class="o">=</span> <span class="n">_surfit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">deficiency</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">message</span> <span class="o">=</span> <span class="n">_surfit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;ier=</span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">tx1</span><span class="p">[:</span><span class="n">nx</span><span class="p">],</span> <span class="n">ty1</span><span class="p">[:</span><span class="n">ny</span><span class="p">],</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span>


<span class="k">class</span><span class="w"> </span><span class="nc">RectBivariateSpline</span><span class="p">(</span><span class="n">BivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bivariate spline approximation over a rectangular mesh.</span>

<span class="sd">    Can be used for both smoothing and interpolating data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x,y : array_like</span>
<span class="sd">        1-D arrays of coordinates in strictly ascending order.</span>
<span class="sd">        Evaluated points outside the data range will be extrapolated.</span>
<span class="sd">    z : array_like</span>
<span class="sd">        2-D array of data with shape (x.size,y.size).</span>
<span class="sd">    bbox : array_like, optional</span>
<span class="sd">        Sequence of length 4 specifying the boundary of the rectangular</span>
<span class="sd">        approximation domain, which means the start and end spline knots of</span>
<span class="sd">        each dimension are set by these values. By default,</span>
<span class="sd">        ``bbox=[min(x), max(x), min(y), max(y)]``.</span>
<span class="sd">    kx, ky : ints, optional</span>
<span class="sd">        Degrees of the bivariate spline. Default is 3.</span>
<span class="sd">    s : float, optional</span>
<span class="sd">        Positive smoothing factor defined for estimation condition:</span>
<span class="sd">        ``sum((z[i]-f(x[i], y[i]))**2, axis=0) &lt;= s`` where f is a spline</span>
<span class="sd">        function. Default is ``s=0``, which is for interpolation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    RectSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh on a sphere</span>
<span class="sd">    SmoothSphereBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline in spherical coordinates</span>
<span class="sd">    LSQSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline in spherical coordinates using weighted</span>
<span class="sd">        least-squares fitting</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    If the input data is such that input dimensions have incommensurate</span>
<span class="sd">    units and differ by many orders of magnitude, the interpolant may have</span>
<span class="sd">    numerical artifacts. Consider rescaling the data before interpolating.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">kx</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bbox</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">bbox</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x must be strictly increasing&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y must be strictly increasing&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x dimension of z must have same number of &#39;</span>
                             <span class="s1">&#39;elements as x&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y dimension of z must have same number of &#39;</span>
                             <span class="s1">&#39;elements as y&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;bbox shape should be (4,)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;s should be s &gt;= 0.0&quot;</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">ye</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">regrid_smth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span>
                                                            <span class="n">ye</span><span class="p">,</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">_surfit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;ier=</span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">tx</span><span class="p">[:</span><span class="n">nx</span><span class="p">],</span> <span class="n">ty</span><span class="p">[:</span><span class="n">ny</span><span class="p">],</span> <span class="n">c</span><span class="p">[:(</span><span class="n">nx</span> <span class="o">-</span> <span class="n">kx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ny</span> <span class="o">-</span> <span class="n">ky</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="n">kx</span><span class="p">,</span> <span class="n">ky</span>


<span class="n">_spherefit_messages</span> <span class="o">=</span> <span class="n">_surfit_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">_spherefit_messages</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ERROR. On entry, the input data are controlled on validity. The following</span>
<span class="s2">       restrictions must be satisfied:</span>
<span class="s2">            -1&lt;=iopt&lt;=1,  m&gt;=2, ntest&gt;=8 ,npest &gt;=8, 0&lt;eps&lt;1,</span>
<span class="s2">            0&lt;=teta(i)&lt;=pi, 0&lt;=phi(i)&lt;=2*pi, w(i)&gt;0, i=1,...,m</span>
<span class="s2">            lwrk1 &gt;= 185+52*v+10*u+14*u*v+8*(u-1)*v**2+8*m</span>
<span class="s2">            kwrk &gt;= m+(ntest-7)*(npest-7)</span>
<span class="s2">            if iopt=-1: 8&lt;=nt&lt;=ntest , 9&lt;=np&lt;=npest</span>
<span class="s2">                        0&lt;tt(5)&lt;tt(6)&lt;...&lt;tt(nt-4)&lt;pi</span>
<span class="s2">                        0&lt;tp(5)&lt;tp(6)&lt;...&lt;tp(np-4)&lt;2*pi</span>
<span class="s2">            if iopt&gt;=0: s&gt;=0</span>
<span class="s2">            if one of these conditions is found to be violated,control</span>
<span class="s2">            is immediately repassed to the calling program. in that</span>
<span class="s2">            case there is no approximation returned.&quot;&quot;&quot;</span>
<span class="n">_spherefit_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">WARNING. The coefficients of the spline returned have been computed as the</span>
<span class="s2">         minimal norm least-squares solution of a (numerically) rank</span>
<span class="s2">         deficient system (deficiency=</span><span class="si">%i</span><span class="s2">, rank=</span><span class="si">%i</span><span class="s2">). Especially if the rank</span>
<span class="s2">         deficiency, which is computed by 6+(nt-8)*(np-7)+ier, is large,</span>
<span class="s2">         the results may be inaccurate. They could also seriously depend on</span>
<span class="s2">         the value of eps.&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SphereBivariateSpline</span><span class="p">(</span><span class="n">_BivariateSplineBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bivariate spline s(x,y) of degrees 3 on a sphere, calculated from a</span>
<span class="sd">    given set of data points (theta,phi,r).</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQUnivariateSpline :</span>
<span class="sd">        a univariate spline using weighted least-squares fitting</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the spline or its derivatives at given positions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta, phi : array_like</span>
<span class="sd">            Input coordinates.</span>

<span class="sd">            If `grid` is False, evaluate the spline at points</span>
<span class="sd">            ``(theta[i], phi[i]), i=0, ..., len(x)-1``.  Standard</span>
<span class="sd">            Numpy broadcasting is obeyed.</span>

<span class="sd">            If `grid` is True: evaluate spline at the grid points</span>
<span class="sd">            defined by the coordinate arrays theta, phi. The arrays</span>
<span class="sd">            must be sorted to increasing order.</span>
<span class="sd">            The ordering of axes is consistent with</span>
<span class="sd">            ``np.meshgrid(..., indexing=&quot;ij&quot;)`` and inconsistent with the</span>
<span class="sd">            default ordering ``np.meshgrid(..., indexing=&quot;xy&quot;)``.</span>
<span class="sd">        dtheta : int, optional</span>
<span class="sd">            Order of theta-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>
<span class="sd">        dphi : int</span>
<span class="sd">            Order of phi-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>
<span class="sd">        grid : bool</span>
<span class="sd">            Whether to evaluate the results on a grid spanned by the</span>
<span class="sd">            input arrays, or at points specified by the input arrays.</span>

<span class="sd">            .. versionadded:: 0.14.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Suppose that we want to use splines to interpolate a bivariate function on a</span>
<span class="sd">        sphere. The value of the function is known on a grid of longitudes and</span>
<span class="sd">        colatitudes.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import RectSphereBivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; def f(theta, phi):</span>
<span class="sd">        ...     return np.sin(theta) * np.cos(phi)</span>

<span class="sd">        We evaluate the function on the grid. Note that the default indexing=&quot;xy&quot;</span>
<span class="sd">        of meshgrid would result in an unexpected (transposed) result after</span>
<span class="sd">        interpolation.</span>

<span class="sd">        &gt;&gt;&gt; thetaarr = np.linspace(0, np.pi, 22)[1:-1]</span>
<span class="sd">        &gt;&gt;&gt; phiarr = np.linspace(0, 2 * np.pi, 21)[:-1]</span>
<span class="sd">        &gt;&gt;&gt; thetagrid, phigrid = np.meshgrid(thetaarr, phiarr, indexing=&quot;ij&quot;)</span>
<span class="sd">        &gt;&gt;&gt; zdata = f(thetagrid, phigrid)</span>

<span class="sd">        We next set up the interpolator and use it to evaluate the function</span>
<span class="sd">        on a finer grid.</span>

<span class="sd">        &gt;&gt;&gt; rsbs = RectSphereBivariateSpline(thetaarr, phiarr, zdata)</span>
<span class="sd">        &gt;&gt;&gt; thetaarr_fine = np.linspace(0, np.pi, 200)</span>
<span class="sd">        &gt;&gt;&gt; phiarr_fine = np.linspace(0, 2 * np.pi, 200)</span>
<span class="sd">        &gt;&gt;&gt; zdata_fine = rsbs(thetaarr_fine, phiarr_fine)</span>

<span class="sd">        Finally we plot the coarsly-sampled input data alongside the</span>
<span class="sd">        finely-sampled interpolated data to check that they agree.</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 2, 1)</span>
<span class="sd">        &gt;&gt;&gt; ax2 = fig.add_subplot(1, 2, 2)</span>
<span class="sd">        &gt;&gt;&gt; ax1.imshow(zdata)</span>
<span class="sd">        &gt;&gt;&gt; ax2.imshow(zdata_fine)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">theta</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;requested theta out of bounds.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_BivariateSplineBase</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span>
                                             <span class="n">dx</span><span class="o">=</span><span class="n">dtheta</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">dphi</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the spline at points</span>

<span class="sd">        Returns the interpolated value at ``(theta[i], phi[i]),</span>
<span class="sd">        i=0,...,len(theta)-1``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        theta, phi : array_like</span>
<span class="sd">            Input coordinates. Standard Numpy broadcasting is obeyed.</span>
<span class="sd">            The ordering of axes is consistent with</span>
<span class="sd">            np.meshgrid(..., indexing=&quot;ij&quot;) and inconsistent with the</span>
<span class="sd">            default ordering np.meshgrid(..., indexing=&quot;xy&quot;).</span>
<span class="sd">        dtheta : int, optional</span>
<span class="sd">            Order of theta-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>
<span class="sd">        dphi : int, optional</span>
<span class="sd">            Order of phi-derivative</span>

<span class="sd">            .. versionadded:: 0.14.0</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Suppose that we want to use splines to interpolate a bivariate function on a</span>
<span class="sd">        sphere. The value of the function is known on a grid of longitudes and</span>
<span class="sd">        colatitudes.</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import RectSphereBivariateSpline</span>
<span class="sd">        &gt;&gt;&gt; def f(theta, phi):</span>
<span class="sd">        ...     return np.sin(theta) * np.cos(phi)</span>

<span class="sd">        We evaluate the function on the grid. Note that the default indexing=&quot;xy&quot;</span>
<span class="sd">        of meshgrid would result in an unexpected (transposed) result after</span>
<span class="sd">        interpolation.</span>

<span class="sd">        &gt;&gt;&gt; thetaarr = np.linspace(0, np.pi, 22)[1:-1]</span>
<span class="sd">        &gt;&gt;&gt; phiarr = np.linspace(0, 2 * np.pi, 21)[:-1]</span>
<span class="sd">        &gt;&gt;&gt; thetagrid, phigrid = np.meshgrid(thetaarr, phiarr, indexing=&quot;ij&quot;)</span>
<span class="sd">        &gt;&gt;&gt; zdata = f(thetagrid, phigrid)</span>

<span class="sd">        We next set up the interpolator and use it to evaluate the function</span>
<span class="sd">        at points not on the original grid.</span>

<span class="sd">        &gt;&gt;&gt; rsbs = RectSphereBivariateSpline(thetaarr, phiarr, zdata)</span>
<span class="sd">        &gt;&gt;&gt; thetainterp = np.linspace(thetaarr[0], thetaarr[-1], 200)</span>
<span class="sd">        &gt;&gt;&gt; phiinterp = np.linspace(phiarr[0], phiarr[-1], 200)</span>
<span class="sd">        &gt;&gt;&gt; zinterp = rsbs.ev(thetainterp, phiinterp)</span>

<span class="sd">        Finally we plot the original data for a diagonal slice through the</span>
<span class="sd">        initial grid, and the spline approximation along the same slice.</span>

<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 1, 1)</span>
<span class="sd">        &gt;&gt;&gt; ax1.plot(np.sin(thetaarr) * np.sin(phiarr), np.diag(zdata), &quot;or&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ax1.plot(np.sin(thetainterp) * np.sin(phiinterp), zinterp, &quot;-b&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="n">dtheta</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="n">dphi</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SmoothSphereBivariateSpline</span><span class="p">(</span><span class="n">SphereBivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth bivariate spline approximation in spherical coordinates.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta, phi, r : array_like</span>
<span class="sd">        1-D sequences of data points (order is not important). Coordinates</span>
<span class="sd">        must be given in radians. Theta must lie within the interval</span>
<span class="sd">        ``[0, pi]``, and phi must lie within the interval ``[0, 2pi]``.</span>
<span class="sd">    w : array_like, optional</span>
<span class="sd">        Positive 1-D sequence of weights.</span>
<span class="sd">    s : float, optional</span>
<span class="sd">        Positive smoothing factor defined for estimation condition:</span>
<span class="sd">        ``sum((w(i)*(r(i) - s(theta(i), phi(i))))**2, axis=0) &lt;= s``</span>
<span class="sd">        Default ``s=len(w)`` which should be a good value if ``1/w[i]`` is an</span>
<span class="sd">        estimate of the standard deviation of ``r[i]``.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        A threshold for determining the effective rank of an over-determined</span>
<span class="sd">        linear system of equations. `eps` should have a value within the open</span>
<span class="sd">        interval ``(0, 1)``, the default is 1e-16.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    RectSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh on a sphere</span>
<span class="sd">    LSQSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline in spherical coordinates using weighted</span>
<span class="sd">        least-squares fitting</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh.</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For more information, see the FITPACK_ site about this function.</span>

<span class="sd">    .. _FITPACK: http://www.netlib.org/dierckx/sphere.f</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we have global data on a coarse grid (the input data does not</span>
<span class="sd">    have to be on a grid):</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; theta = np.linspace(0., np.pi, 7)</span>
<span class="sd">    &gt;&gt;&gt; phi = np.linspace(0., 2*np.pi, 9)</span>
<span class="sd">    &gt;&gt;&gt; data = np.empty((theta.shape[0], phi.shape[0]))</span>
<span class="sd">    &gt;&gt;&gt; data[:,0], data[0,:], data[-1,:] = 0., 0., 0.</span>
<span class="sd">    &gt;&gt;&gt; data[1:-1,1], data[1:-1,-1] = 1., 1.</span>
<span class="sd">    &gt;&gt;&gt; data[1,1:-1], data[-2,1:-1] = 1., 1.</span>
<span class="sd">    &gt;&gt;&gt; data[2:-2,2], data[2:-2,-2] = 2., 2.</span>
<span class="sd">    &gt;&gt;&gt; data[2,2:-2], data[-3,2:-2] = 2., 2.</span>
<span class="sd">    &gt;&gt;&gt; data[3,3:-2] = 3.</span>
<span class="sd">    &gt;&gt;&gt; data = np.roll(data, 4, 1)</span>

<span class="sd">    We need to set up the interpolator object</span>

<span class="sd">    &gt;&gt;&gt; lats, lons = np.meshgrid(theta, phi)</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import SmoothSphereBivariateSpline</span>
<span class="sd">    &gt;&gt;&gt; lut = SmoothSphereBivariateSpline(lats.ravel(), lons.ravel(),</span>
<span class="sd">    ...                                   data.T.ravel(), s=3.5)</span>

<span class="sd">    As a first test, we&#39;ll see what the algorithm returns when run on the</span>
<span class="sd">    input coordinates</span>

<span class="sd">    &gt;&gt;&gt; data_orig = lut(theta, phi)</span>

<span class="sd">    Finally we interpolate the data to a finer grid</span>

<span class="sd">    &gt;&gt;&gt; fine_lats = np.linspace(0., np.pi, 70)</span>
<span class="sd">    &gt;&gt;&gt; fine_lons = np.linspace(0., 2 * np.pi, 90)</span>

<span class="sd">    &gt;&gt;&gt; data_smth = lut(fine_lats, fine_lons)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax1 = fig.add_subplot(131)</span>
<span class="sd">    &gt;&gt;&gt; ax1.imshow(data, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2 = fig.add_subplot(132)</span>
<span class="sd">    &gt;&gt;&gt; ax2.imshow(data_orig, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax3 = fig.add_subplot(133)</span>
<span class="sd">    &gt;&gt;&gt; ax3.imshow(data_smth, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1E-16</span><span class="p">):</span>

        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="c1"># input validation</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;theta should be between [0, pi]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">phi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">phi</span> <span class="o">&lt;=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;phi should be between [0, 2pi]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;w should be positive&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;s should be positive&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;eps should be between (0, 1)&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">nt_</span><span class="p">,</span> <span class="n">tt_</span><span class="p">,</span> <span class="n">np_</span><span class="p">,</span> <span class="n">tp_</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">spherfit_smth</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span>
                                                                    <span class="n">r</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                                                                    <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">_spherefit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;ier=</span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">tt_</span><span class="p">[:</span><span class="n">nt_</span><span class="p">],</span> <span class="n">tp_</span><span class="p">[:</span><span class="n">np_</span><span class="p">],</span> <span class="n">c</span><span class="p">[:(</span><span class="n">nt_</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np_</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">phi</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">phi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;requested phi out of bounds.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SphereBivariateSpline</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="n">dtheta</span><span class="p">,</span>
                                              <span class="n">dphi</span><span class="o">=</span><span class="n">dphi</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LSQSphereBivariateSpline</span><span class="p">(</span><span class="n">SphereBivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Weighted least-squares bivariate spline approximation in spherical</span>
<span class="sd">    coordinates.</span>

<span class="sd">    Determines a smoothing bicubic spline according to a given</span>
<span class="sd">    set of knots in the `theta` and `phi` directions.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta, phi, r : array_like</span>
<span class="sd">        1-D sequences of data points (order is not important). Coordinates</span>
<span class="sd">        must be given in radians. Theta must lie within the interval</span>
<span class="sd">        ``[0, pi]``, and phi must lie within the interval ``[0, 2pi]``.</span>
<span class="sd">    tt, tp : array_like</span>
<span class="sd">        Strictly ordered 1-D sequences of knots coordinates.</span>
<span class="sd">        Coordinates must satisfy ``0 &lt; tt[i] &lt; pi``, ``0 &lt; tp[i] &lt; 2*pi``.</span>
<span class="sd">    w : array_like, optional</span>
<span class="sd">        Positive 1-D sequence of weights, of the same length as `theta`, `phi`</span>
<span class="sd">        and `r`.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        A threshold for determining the effective rank of an over-determined</span>
<span class="sd">        linear system of equations. `eps` should have a value within the</span>
<span class="sd">        open interval ``(0, 1)``, the default is 1e-16.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    RectSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh on a sphere</span>
<span class="sd">    SmoothSphereBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline in spherical coordinates</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh.</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For more information, see the FITPACK_ site about this function.</span>

<span class="sd">    .. _FITPACK: http://www.netlib.org/dierckx/sphere.f</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we have global data on a coarse grid (the input data does not</span>
<span class="sd">    have to be on a grid):</span>

<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import LSQSphereBivariateSpline</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; theta = np.linspace(0, np.pi, num=7)</span>
<span class="sd">    &gt;&gt;&gt; phi = np.linspace(0, 2*np.pi, num=9)</span>
<span class="sd">    &gt;&gt;&gt; data = np.empty((theta.shape[0], phi.shape[0]))</span>
<span class="sd">    &gt;&gt;&gt; data[:,0], data[0,:], data[-1,:] = 0., 0., 0.</span>
<span class="sd">    &gt;&gt;&gt; data[1:-1,1], data[1:-1,-1] = 1., 1.</span>
<span class="sd">    &gt;&gt;&gt; data[1,1:-1], data[-2,1:-1] = 1., 1.</span>
<span class="sd">    &gt;&gt;&gt; data[2:-2,2], data[2:-2,-2] = 2., 2.</span>
<span class="sd">    &gt;&gt;&gt; data[2,2:-2], data[-3,2:-2] = 2., 2.</span>
<span class="sd">    &gt;&gt;&gt; data[3,3:-2] = 3.</span>
<span class="sd">    &gt;&gt;&gt; data = np.roll(data, 4, 1)</span>

<span class="sd">    We need to set up the interpolator object. Here, we must also specify the</span>
<span class="sd">    coordinates of the knots to use.</span>

<span class="sd">    &gt;&gt;&gt; lats, lons = np.meshgrid(theta, phi)</span>
<span class="sd">    &gt;&gt;&gt; knotst, knotsp = theta.copy(), phi.copy()</span>
<span class="sd">    &gt;&gt;&gt; knotst[0] += .0001</span>
<span class="sd">    &gt;&gt;&gt; knotst[-1] -= .0001</span>
<span class="sd">    &gt;&gt;&gt; knotsp[0] += .0001</span>
<span class="sd">    &gt;&gt;&gt; knotsp[-1] -= .0001</span>
<span class="sd">    &gt;&gt;&gt; lut = LSQSphereBivariateSpline(lats.ravel(), lons.ravel(),</span>
<span class="sd">    ...                                data.T.ravel(), knotst, knotsp)</span>

<span class="sd">    As a first test, we&#39;ll see what the algorithm returns when run on the</span>
<span class="sd">    input coordinates</span>

<span class="sd">    &gt;&gt;&gt; data_orig = lut(theta, phi)</span>

<span class="sd">    Finally we interpolate the data to a finer grid</span>

<span class="sd">    &gt;&gt;&gt; fine_lats = np.linspace(0., np.pi, 70)</span>
<span class="sd">    &gt;&gt;&gt; fine_lons = np.linspace(0., 2*np.pi, 90)</span>
<span class="sd">    &gt;&gt;&gt; data_lsq = lut(fine_lats, fine_lons)</span>

<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax1 = fig.add_subplot(131)</span>
<span class="sd">    &gt;&gt;&gt; ax1.imshow(data, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2 = fig.add_subplot(132)</span>
<span class="sd">    &gt;&gt;&gt; ax2.imshow(data_orig, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax3 = fig.add_subplot(133)</span>
<span class="sd">    &gt;&gt;&gt; ax3.imshow(data_lsq, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1E-16</span><span class="p">):</span>

        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">tt</span><span class="p">,</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tt</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">theta</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;theta should be between [0, pi]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">phi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">phi</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;phi should be between [0, 2pi]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">tt</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tt</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tt should be between (0, pi)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">tp</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tp</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tp should be between (0, 2pi)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;w should be positive&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;eps should be between (0, 1)&#39;</span><span class="p">)</span>

        <span class="n">nt_</span><span class="p">,</span> <span class="n">np_</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">tt</span><span class="p">),</span> <span class="mi">8</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
        <span class="n">tt_</span><span class="p">,</span> <span class="n">tp_</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nt_</span><span class="p">,),</span> <span class="nb">float</span><span class="p">),</span> <span class="n">zeros</span><span class="p">((</span><span class="n">np_</span><span class="p">,),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">tt_</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="n">tp_</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tt</span><span class="p">,</span> <span class="n">tp</span>
        <span class="n">tt_</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:],</span> <span class="n">tp_</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">tt_</span><span class="p">,</span> <span class="n">tp_</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">spherfit_lsq</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">tt_</span><span class="p">,</span> <span class="n">tp_</span><span class="p">,</span>
                                                        <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ier</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="n">_spherefit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;ier=</span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">tt_</span><span class="p">,</span> <span class="n">tp_</span><span class="p">,</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">phi</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">phi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">phi</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;requested phi out of bounds.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SphereBivariateSpline</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="n">dtheta</span><span class="p">,</span>
                                              <span class="n">dphi</span><span class="o">=</span><span class="n">dphi</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>


<span class="n">_spfit_messages</span> <span class="o">=</span> <span class="n">_surfit_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">_spfit_messages</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">ERROR: on entry, the input data are controlled on validity</span>
<span class="s2">       the following restrictions must be satisfied.</span>
<span class="s2">          -1&lt;=iopt(1)&lt;=1, 0&lt;=iopt(2)&lt;=1, 0&lt;=iopt(3)&lt;=1,</span>
<span class="s2">          -1&lt;=ider(1)&lt;=1, 0&lt;=ider(2)&lt;=1, ider(2)=0 if iopt(2)=0.</span>
<span class="s2">          -1&lt;=ider(3)&lt;=1, 0&lt;=ider(4)&lt;=1, ider(4)=0 if iopt(3)=0.</span>
<span class="s2">          mu &gt;= mumin (see above), mv &gt;= 4, nuest &gt;=8, nvest &gt;= 8,</span>
<span class="s2">          kwrk&gt;=5+mu+mv+nuest+nvest,</span>
<span class="s2">          lwrk &gt;= 12+nuest*(mv+nvest+3)+nvest*24+4*mu+8*mv+max(nuest,mv+nvest)</span>
<span class="s2">          0&lt; u(i-1)&lt;u(i)&lt; pi,i=2,..,mu,</span>
<span class="s2">          -pi&lt;=v(1)&lt; pi, v(1)&lt;v(i-1)&lt;v(i)&lt;v(1)+2*pi, i=3,...,mv</span>
<span class="s2">          if iopt(1)=-1: 8&lt;=nu&lt;=min(nuest,mu+6+iopt(2)+iopt(3))</span>
<span class="s2">                         0&lt;tu(5)&lt;tu(6)&lt;...&lt;tu(nu-4)&lt; pi</span>
<span class="s2">                         8&lt;=nv&lt;=min(nvest,mv+7)</span>
<span class="s2">                         v(1)&lt;tv(5)&lt;tv(6)&lt;...&lt;tv(nv-4)&lt;v(1)+2*pi</span>
<span class="s2">                         the schoenberg-whitney conditions, i.e. there must be</span>
<span class="s2">                         subset of grid coordinates uu(p) and vv(q) such that</span>
<span class="s2">                            tu(p) &lt; uu(p) &lt; tu(p+4) ,p=1,...,nu-4</span>
<span class="s2">                            (iopt(2)=1 and iopt(3)=1 also count for a uu-value</span>
<span class="s2">                            tv(q) &lt; vv(q) &lt; tv(q+4) ,q=1,...,nv-4</span>
<span class="s2">                            (vv(q) is either a value v(j) or v(j)+2*pi)</span>
<span class="s2">          if iopt(1)&gt;=0: s&gt;=0</span>
<span class="s2">          if s=0: nuest&gt;=mu+6+iopt(2)+iopt(3), nvest&gt;=mv+7</span>
<span class="s2">       if one of these conditions is found to be violated,control is</span>
<span class="s2">       immediately repassed to the calling program. in that case there is no</span>
<span class="s2">       approximation returned.&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">RectSphereBivariateSpline</span><span class="p">(</span><span class="n">SphereBivariateSpline</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bivariate spline approximation over a rectangular mesh on a sphere.</span>

<span class="sd">    Can be used for smoothing data.</span>

<span class="sd">    .. versionadded:: 0.11.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    u : array_like</span>
<span class="sd">        1-D array of colatitude coordinates in strictly ascending order.</span>
<span class="sd">        Coordinates must be given in radians and lie within the open interval</span>
<span class="sd">        ``(0, pi)``.</span>
<span class="sd">    v : array_like</span>
<span class="sd">        1-D array of longitude coordinates in strictly ascending order.</span>
<span class="sd">        Coordinates must be given in radians. First element (``v[0]``) must lie</span>
<span class="sd">        within the interval ``[-pi, pi)``. Last element (``v[-1]``) must satisfy</span>
<span class="sd">        ``v[-1] &lt;= v[0] + 2*pi``.</span>
<span class="sd">    r : array_like</span>
<span class="sd">        2-D array of data with shape ``(u.size, v.size)``.</span>
<span class="sd">    s : float, optional</span>
<span class="sd">        Positive smoothing factor defined for estimation condition</span>
<span class="sd">        (``s=0`` is for interpolation).</span>
<span class="sd">    pole_continuity : bool or (bool, bool), optional</span>
<span class="sd">        Order of continuity at the poles ``u=0`` (``pole_continuity[0]``) and</span>
<span class="sd">        ``u=pi`` (``pole_continuity[1]``).  The order of continuity at the pole</span>
<span class="sd">        will be 1 or 0 when this is True or False, respectively.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    pole_values : float or (float, float), optional</span>
<span class="sd">        Data values at the poles ``u=0`` and ``u=pi``.  Either the whole</span>
<span class="sd">        parameter or each individual element can be None.  Defaults to None.</span>
<span class="sd">    pole_exact : bool or (bool, bool), optional</span>
<span class="sd">        Data value exactness at the poles ``u=0`` and ``u=pi``.  If True, the</span>
<span class="sd">        value is considered to be the right function value, and it will be</span>
<span class="sd">        fitted exactly. If False, the value will be considered to be a data</span>
<span class="sd">        value just like the other data values.  Defaults to False.</span>
<span class="sd">    pole_flat : bool or (bool, bool), optional</span>
<span class="sd">        For the poles at ``u=0`` and ``u=pi``, specify whether or not the</span>
<span class="sd">        approximation has vanishing derivatives.  Defaults to False.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BivariateSpline :</span>
<span class="sd">        a base class for bivariate splines.</span>
<span class="sd">    UnivariateSpline :</span>
<span class="sd">        a smooth univariate spline to fit a given set of data points.</span>
<span class="sd">    SmoothBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline through the given points</span>
<span class="sd">    LSQBivariateSpline :</span>
<span class="sd">        a bivariate spline using weighted least-squares fitting</span>
<span class="sd">    SmoothSphereBivariateSpline :</span>
<span class="sd">        a smoothing bivariate spline in spherical coordinates</span>
<span class="sd">    LSQSphereBivariateSpline :</span>
<span class="sd">        a bivariate spline in spherical coordinates using weighted</span>
<span class="sd">        least-squares fitting</span>
<span class="sd">    RectBivariateSpline :</span>
<span class="sd">        a bivariate spline over a rectangular mesh.</span>
<span class="sd">    bisplrep :</span>
<span class="sd">        a function to find a bivariate B-spline representation of a surface</span>
<span class="sd">    bisplev :</span>
<span class="sd">        a function to evaluate a bivariate B-spline and its derivatives</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Currently, only the smoothing spline approximation (``iopt[0] = 0`` and</span>
<span class="sd">    ``iopt[0] = 1`` in the FITPACK routine) is supported.  The exact</span>
<span class="sd">    least-squares spline approximation is not implemented yet.</span>

<span class="sd">    When actually performing the interpolation, the requested `v` values must</span>
<span class="sd">    lie within the same length 2pi interval that the original `v` values were</span>
<span class="sd">    chosen from.</span>

<span class="sd">    For more information, see the FITPACK_ site about this function.</span>

<span class="sd">    .. _FITPACK: http://www.netlib.org/dierckx/spgrid.f</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Suppose we have global data on a coarse grid</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; lats = np.linspace(10, 170, 9) * np.pi / 180.</span>
<span class="sd">    &gt;&gt;&gt; lons = np.linspace(0, 350, 18) * np.pi / 180.</span>
<span class="sd">    &gt;&gt;&gt; data = np.dot(np.atleast_2d(90. - np.linspace(-80., 80., 18)).T,</span>
<span class="sd">    ...               np.atleast_2d(180. - np.abs(np.linspace(0., 350., 9)))).T</span>

<span class="sd">    We want to interpolate it to a global one-degree grid</span>

<span class="sd">    &gt;&gt;&gt; new_lats = np.linspace(1, 180, 180) * np.pi / 180</span>
<span class="sd">    &gt;&gt;&gt; new_lons = np.linspace(1, 360, 360) * np.pi / 180</span>
<span class="sd">    &gt;&gt;&gt; new_lats, new_lons = np.meshgrid(new_lats, new_lons)</span>

<span class="sd">    We need to set up the interpolator object</span>

<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import RectSphereBivariateSpline</span>
<span class="sd">    &gt;&gt;&gt; lut = RectSphereBivariateSpline(lats, lons, data)</span>

<span class="sd">    Finally we interpolate the data.  The `RectSphereBivariateSpline` object</span>
<span class="sd">    only takes 1-D arrays as input, therefore we need to do some reshaping.</span>

<span class="sd">    &gt;&gt;&gt; data_interp = lut.ev(new_lats.ravel(),</span>
<span class="sd">    ...                      new_lons.ravel()).reshape((360, 180)).T</span>

<span class="sd">    Looking at the original and the interpolated data, one can see that the</span>
<span class="sd">    interpolant reproduces the original data very well:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax1 = fig.add_subplot(211)</span>
<span class="sd">    &gt;&gt;&gt; ax1.imshow(data, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax2 = fig.add_subplot(212)</span>
<span class="sd">    &gt;&gt;&gt; ax2.imshow(data_interp, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Choosing the optimal value of ``s`` can be a delicate task. Recommended</span>
<span class="sd">    values for ``s`` depend on the accuracy of the data values.  If the user</span>
<span class="sd">    has an idea of the statistical errors on the data, she can also find a</span>
<span class="sd">    proper estimate for ``s``. By assuming that, if she specifies the</span>
<span class="sd">    right ``s``, the interpolator will use a spline ``f(u,v)`` which exactly</span>
<span class="sd">    reproduces the function underlying the data, she can evaluate</span>
<span class="sd">    ``sum((r(i,j)-s(u(i),v(j)))**2)`` to find a good estimate for this ``s``.</span>
<span class="sd">    For example, if she knows that the statistical errors on her</span>
<span class="sd">    ``r(i,j)``-values are not greater than 0.1, she may expect that a good</span>
<span class="sd">    ``s`` should have a value not larger than ``u.size * v.size * (0.1)**2``.</span>

<span class="sd">    If nothing is known about the statistical error in ``r(i,j)``, ``s`` must</span>
<span class="sd">    be determined by trial and error.  The best is then to start with a very</span>
<span class="sd">    large value of ``s`` (to determine the least-squares polynomial and the</span>
<span class="sd">    corresponding upper bound ``fp0`` for ``s``) and then to progressively</span>
<span class="sd">    decrease the value of ``s`` (say by a factor 10 in the beginning, i.e.</span>
<span class="sd">    ``s = fp0 / 10, fp0 / 100, ...``  and more carefully as the approximation</span>
<span class="sd">    shows more detail) to obtain closer fits.</span>

<span class="sd">    The interpolation results for different values of ``s`` give some insight</span>
<span class="sd">    into this process:</span>

<span class="sd">    &gt;&gt;&gt; fig2 = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; s = [3e9, 2e9, 1e9, 1e8]</span>
<span class="sd">    &gt;&gt;&gt; for idx, sval in enumerate(s, 1):</span>
<span class="sd">    ...     lut = RectSphereBivariateSpline(lats, lons, data, s=sval)</span>
<span class="sd">    ...     data_interp = lut.ev(new_lats.ravel(),</span>
<span class="sd">    ...                          new_lons.ravel()).reshape((360, 180)).T</span>
<span class="sd">    ...     ax = fig2.add_subplot(2, 2, idx)</span>
<span class="sd">    ...     ax.imshow(data_interp, interpolation=&#39;nearest&#39;)</span>
<span class="sd">    ...     ax.set_title(f&quot;s = {sval:g}&quot;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">pole_continuity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pole_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">pole_exact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pole_flat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">iopt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dfitpack_int</span><span class="p">)</span>
        <span class="n">ider</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dfitpack_int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pole_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pole_values</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pole_values</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)):</span>
            <span class="n">pole_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">pole_values</span><span class="p">,</span> <span class="n">pole_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pole_continuity</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">pole_continuity</span> <span class="o">=</span> <span class="p">(</span><span class="n">pole_continuity</span><span class="p">,</span> <span class="n">pole_continuity</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pole_exact</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">pole_exact</span> <span class="o">=</span> <span class="p">(</span><span class="n">pole_exact</span><span class="p">,</span> <span class="n">pole_exact</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pole_flat</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">pole_flat</span> <span class="o">=</span> <span class="p">(</span><span class="n">pole_flat</span><span class="p">,</span> <span class="n">pole_flat</span><span class="p">)</span>

        <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">pole_values</span>
        <span class="n">iopt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">pole_continuity</span>
        <span class="k">if</span> <span class="n">r0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ider</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ider</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pole_exact</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">r1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ider</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ider</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pole_exact</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ider</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ider</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pole_flat</span>

        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;u should be between (0, pi)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;v[0] should be between [-pi, pi)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;v[-1] should be v[0] + 2pi or less &#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;u must be strictly increasing&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;v must be strictly increasing&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;u dimension of r must have same number of &#39;</span>
                             <span class="s1">&#39;elements as u&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;v dimension of r must have same number of &#39;</span>
                             <span class="s1">&#39;elements as v&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pole_continuity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">pole_flat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;if pole_continuity is False, so must be &#39;</span>
                             <span class="s1">&#39;pole_flat&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pole_continuity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">pole_flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;if pole_continuity is False, so must be &#39;</span>
                             <span class="s1">&#39;pole_flat&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;s should be positive&#39;</span><span class="p">)</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">FITPACK_LOCK</span><span class="p">:</span>
            <span class="n">nu</span><span class="p">,</span> <span class="n">tu</span><span class="p">,</span> <span class="n">nv</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">dfitpack</span><span class="o">.</span><span class="n">regrid_smth_spher</span><span class="p">(</span><span class="n">iopt</span><span class="p">,</span> <span class="n">ider</span><span class="p">,</span>
                                                                    <span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                                                    <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                                                    <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                                                    <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">_spfit_messages</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ier</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;ier=</span><span class="si">{</span><span class="n">ier</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">tu</span><span class="p">[:</span><span class="n">nu</span><span class="p">],</span> <span class="n">tv</span><span class="p">[:</span><span class="n">nv</span><span class="p">],</span> <span class="n">c</span><span class="p">[:(</span><span class="n">nu</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">nv</span><span class="o">-</span><span class="mi">4</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">degrees</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SphereBivariateSpline</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">dtheta</span><span class="o">=</span><span class="n">dtheta</span><span class="p">,</span>
                                              <span class="n">dphi</span><span class="o">=</span><span class="n">dphi</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By UK Health Security Agency (previously Public Health England)
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>